var tipuesearch = {"pages": [{'title': '各組期末報告說明', 'text': '各組員必須在 W17 上課之前完成期末報告簡報影片上傳與連結, 並放入本網站之"專案口頭簡報"頁面. \n 各組必須在 W17 上課之前完成分組期末報告 pdf 檔案, 上傳至各分組的倉儲中, 並將連結提供至本網站之"專案報告書"頁面. \n 期末報告期間每週對各成員之評分依據下列要項: \n \n 各組員在各分組網站中所呈現之任務執行內容, 並拍攝操作影音 mp4, 將影片標題署名"國立虎尾科技大學-機械設計工程系-協同產品設計實習 B - 學號及影片主題" 後上傳, 並將影片嵌入本網站各章節頁面中. \n 每組將提供組長本網站倉儲協同管理權, 專門處理各組員在各分支或 master 分支中的 pull requests, 各組員必須透過以 bg1, bg2 .... 命名之分支對本倉儲改版, 確定內容無誤後, 再設法由組長處理各 pull requests 之內容合併, Github Pages 將設為與 master 分支對應, 各組員之評分將依據各 pull requests 中所列出之學號與內容判定. \n 請各組員勿將影片檔、圖片檔案或各式檔案送至本倉儲, 影片檔案請上傳至 Youtube, 圖片檔案請送至各組倉儲網站, 各式檔案則請送至各組員 Google Drive 區, 並以嵌入 (iframe), 將影片放入本網站, 其餘圖片或檔案則透過 img 或 a 標註放入各相關頁面. \n \n 2b 分組倉儲 \n https://github.com/mdekmol/cd2019b-task1-2019cdb_t1_g1 \xa0 ( 2bg1 ) \n https://github.com/mdekmol/cd2019b-task1-2019cdb_t1_g2 \xa0 ( 2bg2 ) \n https://github.com/mdekmol/cd2019b-task1-2019cdb_t1_g3_1 \xa0( 2bg3 ) \n https://github.com/mdekmol/cd2019b-task1-2019cdb_t1_g4 \xa0 ( 2bg4 ) \n https://github.com/mdekmol/cd2019b-task1-2019cdb_t1_g5 \xa0( 2bg5 ) \n \n scrum-2 倉儲: \n https://github.com/scrum-2/cd2019b \xa0(沒有遠端網頁, 合併後 網頁 ) \n', 'tags': '', 'url': '各組期末報告說明.html'}, {'title': '執行規劃', 'text': '', 'tags': '', 'url': '執行規劃.html'}, {'title': '手足球系統模擬', 'text': 'BG1 \n 專案成果摘要 \n 我們這學期是做手足球的模擬，用 onshape 做協同設計，將繪製好的立體圖檔轉成 STL，丟到 vrep 進行動態模擬。我們對 " 人對人 "，" 人對電腦 "， " 電腦對電腦 " 及 " 送球機構 " 的模擬寫程式，使得手足球對打都能順利地模擬，送球機構採用升降台進行送球運動，在 vrep 模擬上也遇到了不少問題，花了很多時間去嘗試，最後也有將球順利送回球場上。 \n 專案執行動機 \n 如果我們要製作一個實體的手足球，在實際製作過程中可能會遇到一些問題，例如尺寸上或是組合有一些不如預期的狀況，或是有要修改零件的地方，做出實體再做更改肯定會花更多時間，因此我們可以運用 vrep，在虛擬的地方模擬實際的情況，遇到狀況時只要修改設計圖並再次模擬就行了，這樣可以減少製作實體的時間，還不用浪費材料，可說是一舉兩得。 \n 相關文獻探討 \n Onshape introduction \n V-rep introduction \n Github introduction \n 專案執行成員 \n \n \n \n Leader \n \n Assignments \n \n \n \n \n 40623203 \n 蔡宜芳 \n \n \n 執行規劃 \n V-rep\xa0 人對人模擬和程式 \n V-rep\xa0 送球機構模擬和程式 \n \n \n \n Member \n \n Assignments \n \n \n \n \n 40623206 \n 邱妍蓁 \n \n \n Onshape 繪製手足球台跟抬球機構 \n 爆炸圖 \n \n \n \n \n 40623211 \n 王得榮 \n \n \n 標註送球機構的圖面 \n PDF \n \n \n \n \n 40623212 \n 魏有泉 \n \n 零件表 \n \n \n \n 40623216 \n 楊士平 \n \n 標註手足球的圖面 \n \n \n \n 40623221 \n 蔡和勳 \n \n 投影片 \n \n \n \n 40623222 \n 蔡博淮 \n \n 尺寸分析 \n \n \n \n 40623228 \n 陳永錩 \n \n \n V-rep\xa0 人對電腦模擬和程式 \n \n \n \n \n 40623233 \n 謝宗宏 \n \n V-rep\xa0 人對電腦模擬和程式 \n \n \n \n 40623240 \n 何冠均 \n \n PDF \n \n \n \n 40623245 \n 練峪愷 \n \n \n 標註送球機構的圖面 \n PDF \n \n \n \n \n 執行使用套件 \n Onshape： \n Onshape \xa0 is a \xa0 computer-aided design \xa0 (CAD) \xa0 software \xa0 system, delivered over the Internet via a \xa0 Software as a Service \xa0 (SAAS) model. It makes extensive use of \xa0 cloud computing , with compute-intensive processing and \xa0 rendering \xa0 performed on \xa0 Internet -based \xa0 servers , and users are able to interact with the system via a \xa0 web browser \xa0 or the \xa0 iOS \xa0 and \xa0 Android \xa0 apps. \n Onshape allows teams to collaborate on a single shared design, the same way multiple writers can work together editing a shared document via cloud services. \xa0 It is primarily focused on mechanical CAD (MCAD) and is used for product and machinery design across many industries, including \xa0 consumer electronics , mechanical \xa0 machinery , \xa0 medical devices , \xa0 3D printing , machine parts, and industrial equipment. \n Onshape upgrades are released directly to the web interface, and the software does not require maintenance work from the user. \n Founded in 2012, Onshape is based in \xa0 Cambridge, Massachusetts \xa0 (USA), with offices in \xa0 Singapore \xa0 and \xa0 Pune, India . \xa0 Its leadership team includes several engineers and executives who originated \xa0 SolidWorks , a popular 3D CAD program that runs on Windows computers. \xa0 Onshape’s co-founders include two former SolidWorks CEOs, \xa0 Jon Hirschtick \xa0 and John McEleney. \n V-rep： \n \n V-REP provides a unified framework combining many powerful internal and external libraries that are often useful for robotics simulations. This includes dynamic simulation engines, forward/inverse kinematics tools, collision detection libraries, vision sensor simulations, path planning, GUI development tools, and built-in models of many common robots \n V-REP is highly extensible. V-REP developers provide an API that allows one to write custom plugins that add new features. You can embed \xa0 Lua \xa0 scripts directly into a simulation scene that, for example, process simulated sensor data, run control algorithms, implement user interfaces, or even send data to a physical robot. They also provide a remote API that allows one to develop standalone applications in many programming languages that are able to pass data in and out of a running V-REP simulation. \n \n Github： \n GitHub 是透過 Git 進行 版本控制 的軟體原始碼代管服務平台，由GitHub公司（曾稱Logical Awesome）的開發者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用 Ruby on Rails 編寫而成。 \n GitHub同時提供付費帳戶和免費帳戶。這兩種帳戶都可以建立公開或私有的程式碼倉庫，但付費用戶支援更多功能。根據在2009年的Git用戶調查，GitHub是最流行的Git存取站點。除了允許個人和組織建立和存取保管中的程式碼以外，它也提供了一些方便社會化共同軟體開發的功能，即一般人口中的社群功能，包括允許用戶追蹤其他用戶、組織、軟體庫的動態，對軟體程式碼的改動和bug提出評論等。GitHub也提供了圖表功能，用於概觀顯示開發者們怎樣在程式碼庫上工作以及軟體的開發活躍程度。 \n 專案執行過程規劃 \n 尋找資料 --> 分配工作 --> 執行各自工作 --> 與各組員討論問題 --> 實踐想法 -->\xa0 Onshape 組合\xa0 --> V-rep 模擬 --> lua 程式撰寫 --> 製作 PDF -->完成 \n 專案執行內容 \n 專案結論 \n \n BG2 \n (40623202,40623209) \n 專案成果摘要 \n 本次專案成果其分為三種: 人v.s人 \xa0 / \xa0 人v.s電腦 \xa0 / \xa0 電腦v.s電腦 \n 其成果是三種都有做出來，其中三種的差異主要是在程式定義上的問題，人v.s人是參考老師的版本下去做更改，在做人v.s電腦與電腦v.s電腦的過程中，需先將電腦的部分做出來，之後再與人的程式做個整合與優化的動作，其實可以一次寫完整個程式，但由於非資訊類科系，故在程式上土法煉鋼，將每一部份完成後再進行統合，雖花費時間較多，但也成功做出成果。 \n 完成此次的專案須具備基本對V-rep的認識、OnShape熟悉的操作，以及和全班協同過程中能夠有除錯的能力。在程式撰寫方面，因非資訊類別科系，故在撰寫程式上需不斷的嘗試，了解其邏輯架構，才能完成；Onshape 設計中，因負責組員對其軟體有相當程度的技能，故在繪製設計圖上十分上手；而在全班協同中每個人都必須擁有除錯的能力，但由於是第一次與全班共同協同，所以在執行的過程中會有各種錯誤出現，都必須藉由討論來解決問題。 \n 在執行專案過程中因對程式不熟悉，故需不斷地找出錯誤，才能做出三種成果，而如何找出錯誤以及如何解決，詳見專案討論的部分。 \n 專案執行動機 \n 近年來科技發展，程式設計與系統模擬早以統合成一塊。本學期的手足球模擬，跳脫以往人 v.s. 人的競賽方式，以及人 v.s. 電腦，我們也想做出電腦 v.s. 電腦的系統模擬，其動機為前陣子 Alpha go \xa0 擊敗不少各國高手，這讓我們想驗證電腦與電腦是否能力相當，又會如何運作；而中間使用的運算法並沒有 Alpha go \xa0 這麼複雜，但在機構設計以及運動模擬中佔了很大一部分，而我們認為電腦 v.s. 電腦的程式雖可以設計，但中間是否參雜些運氣成分還有待關注。 \n 相關文獻探討 \n 專案執行成員 \n \n \n \n Leader \n Assignments \n \n \n 40623247廖峻祥 \n 執行規劃、PDF \n \n \n \n \n \n \n \n Member \n Assignments \n \n \n 40623202 吳姍蓉 \n 執行規劃 \n \n \n 40623209 李芳瑜 \n 執行規劃 \n \n \n 40623214 吳家文 \n Onshape \n \n \n 40623215 吳柏毅 \n Onshape \n \n \n 40623220 蔡崇廷 \n v-rep 模擬 \n \n \n 40623236 黃子峰 \n v-rep 模擬 \n \n \n 40623249 李秉樺 \n v-rep 模擬 \n \n \n 40623250 湯峻傑 \n Onshape \n \n \n 40623251 鄧靖宣 \n 無 \n \n \n 40423217 阮奕誠 \n v-rep 模擬 \n \n \n \n 執行使用套件 \n \n \n \n 套件名稱 \n 介紹 \n 功能 \n \n \n V-rep \n \n VREP集成了建模 / 编程 / 物理引擎。具有四款物理引擎， Bullet/ODE/Vortex/Newton 。 \n 其開源、快速、靈活的建模和模擬，同時有一定的模擬精度，為研發中非常重要的一部分。 \n 特色 : \n \n 建模和编程環境方便。 \n \n \xa0 \xa0 2. VREP本身是開源的。使用 LUA 语言进行编程。 \n (LUA 是一個體積很小的编程语言，但集成了 C 語言， Python ， Matlab 等等其他主流语言，使用上相對容易 ) \n \n \n 1.跨平台 \n 2.六種編成方法 \n 3.多種編成語言 \n 4.完整的運動學計算器 \n 5.路徑規劃 \n 6.與現實接近的傳感器 \n (在檢測區域中的最短距離計算) \n \n \n \n OnShape \n \n Onshape 只要打開瀏覽器即可使用，使用的永遠都是最新版本，因此兼容性不會成為問题。 \n Onshape 具備了有限的實體建模能力，其幾何實體是由 \xa0Part Studio\xa0 這個多部件幾何體開發環境來生成的，没有文件的概念，因此也没有外部参照的依赖性问题。 \n 特色 : \n 1.線上協同設計。 \n 2.容易上手的建模策略3.設計流程的重視。 \n \n \n 繪圖功能其他繪圖軟體並無太大差異，其不同點在於 : \n 1.\xa0 比較指令 \n 2.\xa0 跟隨模式 \n 3.\xa0 匯入 / 導入 DXF 檔案 \n 4.\xa0 捷徑工具列 \n 5.\xa0 加入評論 \n 6.\xa0 插入時的快照模式 \n \n \n \n Github \n \n GitHub是透過 Git 進行 版本控制 的軟體原始碼代管服務平台，由 GitHub 公司的開發者使用 Ruby on Rails 編寫而成。 \n 特色 : \n 1.提供付費帳戶和免費帳戶。 \n 2.GitHub也提供了圖表功能。 \n 3.Git 程式碼擁有開放和公開散播能力極佳的特性，提供了社群互動功能。 \n \n \n GitHub 支援以下格式和功能： \n 1.文件：包括自動生成的、採用類 Markdown 語言的 Readme 檔案。 \n 2.問題追蹤系統（同時可用於功能需求） \n 3. Wiki \n 4.GitHub Pages支援用戶透過軟體倉庫建立靜態網站或靜態部落格。 \n 5. 任務列表 \n 6. 甘特圖 \n \n \n CMSimfly \n \n 是一套簡單的網際內容管理系統 ,\xa0 採用 Flask\xa0 網際框架 ,\xa0 以 \xa0Beautifulsoup\xa0 解讀分頁內容 . \n以 \xa0Python 3\xa0 編寫 ,\xa0 利用 \xa0Flask\xa0 網路框架可以在伺服器運行 ,\xa0 讓使用者利用瀏覽器擷取動態 \xa0WWW\xa0 伺服器所送至近端的 \xa0html\xa0 加上 \xa0Javascript\xa0 程式碼 ,\xa0 然後在瀏覽器中顯示網際內容編輯器。 \n 1.建立可攜環境後即可多人協同 \n \n \n \n 專案執行過程規劃 \n 在專案執行過程規劃中，我們首先是做好分工，再來是各自為自己的工作蒐集資料，並開始著手準備，其在執行的過程中遇到困難都是互相討論解決，最後將大家的想法整合後才完成每一組的模擬。做好小組專案後，開始將自己製作的內容放入個人網站以及簡報，完成從期中考後到期末考週的工作與任務。 \n \n 執行過程規劃甘特圖 \n \n 專案執行內容 \n 延續上半學期的手足球機台，從一開始執行規劃、送球機構的初步設計並使用Onshape繪圖，到最後能用v-rep寫程式做模擬，期間發生了許多問題及困難，例如:送球機構無法順利將球送到指定位置，因為送球機構更改球台的設計導致球員無法順利踢到足球......等( 相關連結 )，都是經過一在地更改才完成了現在的送球機構；在寫程式時，程式碼的定義出現了問題，導致無法順利模擬，但最後也順利解決，得到現在的成果。而這次較特別的是全班一起維護的 期末倉儲 ，本專案的協同工作也是一大重點，透過Github倉儲，讓成員可以同時提交工作，當然，過程中也是遇到很多麻煩，第一次全班一起維護一個倉儲，但經過幾次嘗試之後，也順利的提交pull request，讓期末倉儲得以順利更新。 \n 專案結論 \n \n BG3 \n 專案成果摘要 \n 手足球是由一個英國名為哈羅德的人發明，這個靈感的來自火柴盒，目的是將所以基本足球運動的概念能夠在一個盒子之中表現出來。 \n 而至今手足球已變成老少咸宜的桌上型運動，相對足球來說 某些事情在手足球裡被叫為”unraceable”，因為其操作是可以達到非常快速的，也是因為這個原因瘋迷了全球的玩家! \n 專案執行動機 \n 本次的專案目的為，組織一個十人的團隊，利用"協同"的方式設計出個"可程式控制"的手足球機構，過程中會出現很多的衝突，但也必須藉由溝通來化解所有的問題，唯有不斷的嘗試和修正才能做出最完美的機構，希望透過這次的專案執行讓我們真正體會到"協同"的精隨!! \n 相關文獻探討 \n 專案執行成員 \n \n \n \n Leader \n \n Assignments \n \n \n \n 40423207 朱修林 \n 組織專案執行 、參數設計與繪圖 \n \n \n Member \n \n Assignments \n \n \n \n 40423160 許育誠 \n 送球機構設計模擬、V-rep手足球機構模擬 \n \n \n 40423131 許承恩 \n \n \n \n 40623207 呂沛蓉 \n 細部設計 Bom 表 \n \n \n 40623218 姚浚洧 \n \n \n \n 40623219\xa0 \xa0蘇昱 \n \n \n \n 40623231 周駿麟 \n 送球機構設計模擬 \n \n \n 40623237 黃博隆 \n V-rep手足球機構模擬 \n \n \n 40623241 郭祐齊 \n \n 零組件尺寸分析、專 案報告書、更新網誌 \n \n \n \n 40623246 劉柏瑞 \n 送球機構設計模擬、更新網誌 \n \n \n \n \n \n \n \n 執行使用套件 \n onshape\xa0 、V-rep、Github \n 專案執行過程規劃 \n 分配工作→概略規劃→開始各自完成任務→問題討論→2D構想完成→V-rep模擬→實體化→完成專案 \n 專案執行內容 \n 手足球模擬 \n 專案結論 \n 人對人-1 \n 人對人-2 \n 人對電腦 \n 電腦對電腦 \n \n BG4 \n 專案成果摘要 \n 專案執行動機 \n 相關文獻探討 \n 專案執行成員 \n 執行使用套件 \n 專案執行過程規劃 \n 專案執行內容 \n 專案結論 \n \n BG5 \n 專案成果摘要 \n 專案執行動機 \n 相關文獻探討 \n 專案執行成員 \n 執行使用套件 \n 專案執行過程規劃 \n 專案執行內容 \n 專案結論', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': '設計與繪圖', 'text': '', 'tags': '', 'url': '設計與繪圖.html'}, {'title': '零組件尺寸分析', 'text': 'BG1 \n 手足球系統的零組件尺寸分析 (可行性分析) \n 針對手足球人偶跟手足球之間的干涉情形做出配合圖。(40623222) \n \n 手足球人偶工作圖(40623222) \n \n 手足球桌工作圖(40623222) \n \n \n BG2 \n 手足球系統的零組件尺寸分析 (可行性分析) (40623215) \n \n 傾斜球檯，最中間為最低點，球在進洞後會滾回中心點，成為一個自動回球機構。 \n \n 連同球桿改動，路徑改為和傾斜後的球檯平行，故不會有因球檯傾斜而球員踢不到球的情形。 \n \n BG3 \n 手足球系統的零組件尺寸分析 (可行性分析) \n 分析(一) ☛球員與球 \n 零件尺寸分析過程如下：(40623241) \n \n 讓兩足球員呈現平行狀態時不會出現干涉，可以踢的到球且不會卡到地版 \n \n 原圖手足球座的長為1422mm，若有八根桿子操控踢球員 \n 126*7= 882 \n 1422-882 = 540 \n 守門員後面各有2.7cm的空間運用，所以尺寸分析算是得宜 \n 分析(二)\xa0\xa0 ☛球台四周 \n 過程影片如下 \n https://www.youtube.com/watch?v=Lnd2HEH--hc&t=7s \n 在球桌的四周加上圓弧角，以改善守門員踢不到兩側的狀況 \n \n \n 分析(三)\xa0\xa0☛球員與彈簧 \n 問題 : 當球在球台的最邊緣時，是否會因為彈簧的長度而導致球員無法踢到球，甚至直接從洞口溜過去?(如下圖) \n 分析過程 : https://www.youtube.com/watch?v=RNMicDsQor0 \n 結果 :\xa0 建議讓彈簧軸向的程度調為6.8~7mm最為合適 \n \n \n \n \n BG4 \n 手足球系統的零組件尺寸分析 (可行性分析)(40623238) \n \n 分析球員是否會與手足球座相撞 \n \n 分析球員與球員間是否會相撞 \n \n \n 每隻桿子間距152.4mm，球員與桿子中心到球員底面間距68mm，因此球員與球員間保持152.4-68*2=16.4mm，所以球員不會碰撞到。 \n \n BG5 \n 手足球系統的零組件尺寸分析 (可行性分析) \n 分析足球位於角落時是否卡住使球員無法接觸到球(40623223) \n \n 分析球員與球員之間能在踢到球的情況下不會干涉到(40623223 ) \n \n 因上述之設計因素考量,對球場與球員之間具與長度做修改(40623223 ) \n \n', 'tags': '', 'url': '零組件尺寸分析.html'}, {'title': '參數設計與繪圖', 'text': 'BG1 \n 手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n Onshape 零組件連結 \n 手足球初步設計 \xa040623206 \n \n 送球機構初步設計 \xa040623206 \n \n 手足球+送球機構完成圖 \xa040623206 \n \n \n BG2 \n 手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n Onshape 零組件連結 \n \n BG3 \n 手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n \xa0 \n 桿子長度設定為73+762+308=1143，太短會滑落，太長會對玩家造成干擾。 \n \n 彈簧規格:不鏽鋼線彈簧，壓縮率25%，線徑2.8mm，外徑20mm，內徑14.4mm。 \n \n 球員整體尺寸設計為由老師提供之尺寸作微調。 \n \xa0\xa0 \n \xa0\xa0 \n 軌道是沿著主體的外圍跑，所以基本的尺寸是以主體做設計， \n 內部的尺寸是大於球的直徑，為了要讓球順利滾到送球機構，軌道有設計微小的角度。 \n \n 送球的主要機構，螺旋線圍繞直徑25的圓柱，軌道以螺旋線作掃出，馬達轉4-5圈球就能送到頂端。 \n \n 手足球組利完成圖。 \n Onshape 零組件連結 \n Player \n Ball seat (cover of ball seat) \n Axis \n spring \n Base \n Throwing mechanism assembly \n Assembly \n edit:40423207 \n \n BG4 \n 手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n Onshape 零組件連結 \n \n 手足球台 (40623238) \n \n 擋塊 (40623238) \n \n 手足球人 (40623238) \n \n 握把A (40623238) \n \n 握把B (40623238) \n \n 握把C (40623238) \n \n 握把D (40623238) \n \n 送球機構足球檯桌角 (40623238) \n \n 送球機構活塞支撐桿 (40623238) \n \n 送球機構活塞桿 (40623238) \n \n 送球機構活塞 (40623238) \n \n 送球機構轉輪 (40623238) \n \n 送球機構圓柱 (40623238) \n \n 送球機構滾道 (40623238) \n \n BG5 \n 手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n 足球員 : 這是根據老師給的圖畫出來的，其中很多尺寸都是老師原圖上給的，其他是依據比例做出來的。(40623204) \n \n \n 球 : 大小是以人的大小，依比例畫出來的。(40623204) \n \n \n 握桿 : 直徑老師給的圖畫出來的，長度是以球場的寬度再加上手握的地方得到的長度。(40623204) \n \n \n 球場 : 依市面上常見的手足球滑的大概，握桿的地方是根據老師給的圖設定的，進球的地方是臨時設計的。(40623204) \n \n \n \n Onshape 零組件連結 \n 手足球球場 (40623204) \n 手足球員 (40623204) \n 桿子 (40623204) \n', 'tags': '', 'url': '參數設計與繪圖.html'}, {'title': '細部設計與 BOM', 'text': 'BG1 \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表\xa0 \xa040623212 \n \n \n \n \n \n 零件尺寸圖 \n 零件 放球檯 和放球裝支架 \xa0 (40623245) \n 零件 送球機構用電圈 放球檯用滑塊 送球檯底部固定槽 \xa0(40623245) \n \n 零件 送球檯用滑塊 送球檯用止推滑塊 \xa0(40623245) \n \n 零件 洗球用管路一 送球機構外盒 \xa0(40623245) \n \n 零件 滑塊與送球機構用軸 支架用軸 \xa0(40623245) \n \n 零件部分組裝圖 \n \n 所有桿子的組合\xa040623206 \n \n 送球機構 \xa040623206 \n 3D 零組件爆炸圖 \n foosball - explosion \xa0 40623206 \n \n foosball - explosion drawing \xa0 40623206 \n \n Ball sending mechanism - explosion \xa0 40623206 \n \n Ball sending mechanism - explosion drawing \xa0 40623206 \n \n \n BG2 \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表 (含零組件下載連結) \n 零件尺寸圖 \n 零件尺寸圖 \n 零件部分組裝圖 \n 零件部分組裝圖 \n 3D 零組件爆炸圖 \n 3D 零組件爆炸圖 \n \n BG3 \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表 (含零組件下載連結) \n 零件尺寸圖 \n 手足球檯 \xa0(40623207) \n \n 球桿 \xa0 (40623207) \n \n 足球員 \xa0 (40623207) \n \n 彈簧 \xa0 (40623207) \n \n 球門 \xa0 (40623207) \n \n 螺旋桿 \xa0 (40623207) \n \n 軌道 \xa0 (40623207) \n \n 送球管 \xa0 (40623207) \n \n 中間軌道 \xa0 (40623207) \n \n 零件部分組裝圖 \n 球桿+足球員+彈簧 \xa0 (40623207) \n \n 送球機構 \xa0 (40623207) \n 3D 零組件爆炸圖 \n 爆炸圖 \xa0(40623207) \n \n BG4 \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表 (含零組件下載連結) \n 零組件下載連結 (Final version:螺旋桿運動)(40623224) \n 版本:Onshape(可以自行利用Onshape轉換成其他畫圖軟體的檔案，例如:Solidworks) \n #檔案連結裡面包含所有零件的畫製過程以及工程圖與爆炸分解圖和組合圖，使用模組化的製程讓觀閱者可以自行觀看內容並且自行下載。 \n \n 零組件下載連結 (第一版活塞與連桿) (40623224) \n 版本:inventor2017(有STL檔可以自行用Onshape、Solidworks開啟) \n 零件尺寸圖 \n 其他版本的尺寸圖連結 \n #連結在工程圖下方，請自行點取 \n \n ( 手足球台工程圖 Final version - 40623224) \n \n \n ( 手足球員 工程圖Final version- 40623224) \n \n \n ( 手足球台握把A、B 工程圖Final version - 40623224) \n \n \n ( 手足球台握把C、D 工程圖Final version \xa0- 40623224) \n \n \n ( 手足球握把擋塊 工程圖 Final version \xa0- 40623224) \n \n \n ( 送球機構足球檯桌角 工程圖Final version - 40623224) \n \n \n ( 送球機構 工程圖Final version \xa0- 40623224) \n \n \n ( 送球機構-螺旋桿 工程圖Final version \xa0- 40623224) \n 零件部分組裝圖 \n 零組件零件部分組裝圖展示過程(Final version\xa0 - 40623224 ) \n \n \n \n ( 手足球桿A組合 Final version \xa0- 40623224 ) \n \n \n ( 手足球桿B組合 Final version \xa0- 40623224 ) \n \n \n ( 手足球桿C組合 Final version \xa0- 40623224 ) \n \n \n ( 手足球桿D組合 Final version \xa0- 40623224 ) \n \n \n ( 零件部分組裝圖 Final version \xa0- 40623224 ) \n \n 3D 零組件爆炸圖 \n (零組件爆炸圖展示過程 Final version\xa0 - 40623224 ) \n \n \n \n ( 3D 零組件爆炸圖 Final version \xa0- 40623224 ) \n \n \n BG5 \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表 (含零組件下載連結) \n 零組件下載連結 \n 足球員與桿子材料表  (40623232) \n \n \n 檯子材料表 (40623232) \n \n \n 零件尺寸圖 \n 零件尺寸圖 \n 桿子&足球員零件尺寸 \xa0 (40623232) \n \n 送球機構 零件尺寸1 \xa0 (40623232) \n \n \n 送球機構 零件尺寸2 \xa0 (40623232) \n \n \n 零件部分組裝圖 \n 零件部分組裝圖 \n 3D 零組件爆炸圖 \n 3D 零組件爆炸圖', 'tags': '', 'url': '細部設計與 BOM.html'}, {'title': 'V-rep 動態模擬', 'text': '', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構設計與模擬', 'text': 'BG1 \n 初步想法 \xa040623206 \n \n 送球機構 \xa040623206 \n \n 機構模擬測試 \xa0 (40623203) \n \n 送球機構第一版模擬\xa0 (40623203) \n \n 送球機構左右進洞 \xa0 (40623203) \n \n 送球機構程式 \xa0 (40623203) \n 利用感測器感測到球，使平台下降到下方的感測器，球滾入後，平台上升，回到場內，繼續競賽 \n function sysCall_init()\n-- 定義參數\n    slider=sim.getObjectHandle(\'drive\')\n-- 定義物件 drive 驅動軸為 slider\n    down_Sensor=sim.getObjectHandle("sensor")\n-- 定義物件 sensor 感測器為 down_Sensor\n    down_Sensor_1=sim.getObjectHandle("sensor1")\n-- 定義物件 sensor1 感測器為 down_Sensor_1\n    up_Sensor=sim.getObjectHandle("sensor0")\n-- 定義物件 sensor0 感測器為 up_Sensor\n    speed=0\n-- 初始速度參數\n    A=-1\n-- 初始值\n    b=-1\n-- 初始值\nend\n \nfunction sysCall_actuation()\n    down=sim.readProximitySensor(down_Sensor)\n-- down 讀取 down_Sensor 感測器的狀態\n    down_1=sim.readProximitySensor(down_Sensor_1)\n-- down_1 讀取 down_Sensor_1 感測器的狀態\n    up=sim.readProximitySensor(up_Sensor)\n-- up 讀取 up_Sensor 感測器的狀態\n    if (down>0) or (down_1>0) \n-- 當感測器 down 或 down_1 觸發\n        then A=sim.getSimulationTime()+3 \n-- 設定 A = 模擬時間 + 3 秒 \n    end\n    if (A>0) \n        then sim.setJointTargetVelocity(slider,speed-0.08)\n-- slider 就會以速度 -0.08 向下移動\n    end\n    if (up>0) \n-- 當感測器 up 觸發\n        then b=sim.getSimulationTime()+3 \n-- 設定 b = 模擬時間 + 3 秒 \n    end\n    if (b>0) \n        then sim.setJointTargetVelocity(slider,speed+0.01)\n-- slider 就會以速度 0.01 向上移動\n    end\nend \n \n \n \n \n BG2 \n 初版送球機構設計 (40623215) \n \n 作動方法 \xa0(40623215) \n \n 說明: 以手動方式拉下拉桿讓送球台送上去\xa0 \n 問題 說明:實際路線為弧線，會有死點的產生，故此方法不可行。 \n \n 解決辦法 說明:故此方法改為底下增加一根軸，以馬達推動活塞方式。 \n \n \n 第二版本，改為傾斜球檯，最中間為最低點，球在進洞後會滾回中心點，成為一個自動回球機構。(40623215) \n \n 連同球桿改動，路徑改為和傾斜後的球檯平行，故不會有因球檯傾斜而球員踢不到球的情形。 \n \n \n BG3 \n 從第十二週開始分配工作 ，第十二週開始進行送球機構設計及模擬 \n 第十二週開始設計 門框 ，並且同時匯入到V-rep進行模擬測試門框是否可做動 \n 門框 測試(40423160) \n \n 第十三週設計 軌道 ，先進行單邊的軌道測試 ， 並且同時匯入到V-rep進行模擬測試軌道確認是否可做動 \n 第一版本送球機構 (單邊) 40423160 \n \n 第十四週設計成 雙邊的軌道 ， 遇到的問題 ， 如果雙邊進球會導致圓桶內部結構過於複雜 ， 所以改成先將球送至中點 ， 再由 中間的軌道 送到圓桶 ， 並升到最高點滾到球檯中 ， 並到V-rep進行模擬測試 ，並且設計第二種方式送球 \n 第一版本送球機構(雙邊) \xa0 40423160 \n \n 第二版本送球機構(軌道隱藏在牆中) \xa040423160 \n \n 第十五週將設計好的送球機構與手足球員進行結合 ，組合成 手足球系統 ，並且進行手足球員V-rep模擬 \n V-rep手足球系統模擬 \xa0 (球進門框，球從送球機構完整跑一次，請從 1:48 開始看起)40423160 \n \n 另外版本的送球機構(40623231) \n \n BG4 \n 其他版本的連結 \n 送球機構的初步構想: \n (送球機構的初步構想Final version - 40623224): \n \n \n \n 送球機構設計與模擬: \n 第一版 送球機構設計(有縫隙)(40623224): \n \n \n 第一版 送球機構模擬(有縫隙)(40623227): \n 下載連結: 送球機構第一版 \n 因有縫隙關係導致無法進入 \n \n \n 第二版 送球機構設計(有圓盤)(40623224): \n 第二版更改的內容有把滾道的縫隙填滿，並且再螺旋桿內下方增加一圓盤。 \n \n \n 第二版 送球機構模擬(有圓盤)(40623227): \n 下載連結: 送球機構第二版 \n 雖成功進入可是無法傳送上去 \n \n \n 第三版 送球機構設計(Final version)(40623224): \n Final version更改的內容是圓柱體的部分，由於上一版無法使球滾至上方，後來設計120度的槽，使球進入圓柱體內會隨著螺旋桿滾動而慢慢向上。 \n \n \n 第三版 送球機構模擬(Final version)(40623239): \n 下載連結: 送球機構第三版 \n 已成功完成送球部分 \n \n \n BG5 \n 成品 : (40623248) \n \n \n 目的：將進球門的足球利用機構將足球送回場內，以便於進行下一場球賽。(40623244、40623248) \n 構想：連桿機構 \n 主要連桿的運動行為： \n \n 1.進球後，軌道會引導足球到第一個撥桿的位置 \n \n 2.第一個撥桿 \n \n 3.主動軸(整個連桿機構運動主要桿件) \n \n 4.第二個撥桿 (原本想做成勺子來接球，不過球的相對位置不太好找，於是參考了老師的影片，改成圖片中的樣子，不需要精準抓到足球的位置) \n \n 5.第二個撥桿將足球運送到另一個軌道(將球送入場內) \n \n \n Simulation step( 40623244 ) \n Step1：Import your file to V-rep ( File -> Import -> Mesh ,and choose you file to impot ) \n \n \n Step2：Choose your file ( Click right mouse button -> Edit -> Divide selected shapes,and the selceted shapes will be divided ) \n \n \n Step3：Name each parts ( The picture is an example ) \n \n \n Step4：Add the joints in the shapes ( Click right mouse button -> Add -> Joint -> Revolute ) , and copy the joint to align the corresponding position \n \n \n \n \n \n Step5：Step by step to put each joint and part to the base ( One part connects to one joint\xa0, and there are two joints in the part C that there are two links to drive ) \n \n \n \n \n \n \n \n Step6：Add Dummy in the shapes ( Add -> Dummy ,and set properties (Two Dummies are a group ) ) \n \n \n \n Step7：Step by step to put Dummy to the shapes ( One part connects one joint , and the Dummy one side connects the part , the other side connects the joint ) \n \n \n \n Step8：All parts have to be dynamic\xa0 \n \n \n Step9：This setting to the Drive shaft ( In my file is C ) \n \n \n Step10：Simulate the shapes \n \n \n 以下為連桿機構相關資料： \n 送球機構的初步構想 (40623244) \n 送球機構模擬第一步驟 (40623244) \n \n 送球機構模擬第二步驟 (40623244) \n \n', 'tags': '', 'url': '送球機構設計與模擬.html'}, {'title': '系統功能展示', 'text': 'BG1 \n 手足球模擬系統功能展示 (模擬展示與說明影片) \n foosball \xa0 (40623203) \n foosball people vs ai \xa0\xa0 (40623228&40623233) \n 人對人模擬 \xa0 (40623203) \n 左邊鍵盤控制左邊一、二的移動(W鍵:前踢、S鍵:後踢、A鍵:向右移動、D鍵:向左移動) \n 左邊鍵盤控制左邊三、四的移動(U鍵:前踢、J鍵:後踢、H鍵:向右移動、K鍵:向左移動) \n 右邊鍵盤控制左邊一、二的移動(上鍵:前踢、下鍵:後踢、左鍵:向右移動、右鍵:向左移動) \n 右邊鍵盤控制左邊三、四的移動(8鍵:前踢、5鍵:後踢、4鍵:向右移動、6鍵:向左移動) \n \n 完成品對打 \xa0 (40623203) \n \n left player simulation \xa0 (40623203) \n \n left player finish simulation \xa0 (40623203) \n \n left and right player simulation \xa0 (40623203) \n \n left1 and 2 player simulation\xa0 (40623203) \n \n Foosball\xa0 (40623203) \n \n Foosball - 測試雙人對打加送球機構\xa0 (40623203) \n \n 手足球人對人程式 ( 分四個部分寫 )： \xa0 (40623203) \n 第一部分：left1 and left2\xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n \nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==119) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==115) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==97) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==100) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n  \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then\n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n \n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint\')\nhammer=sim.getObjectHandle(\'left_player\')\nslider=sim.getObjectHandle("left_slider")\njoint_1=sim.getObjectHandle(\'left_joint_1\')\nhammer_1=sim.getObjectHandle(\'left_player_1\')\nslider_1=sim.getObjectHandle("left_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n 第二部分：left3 and left4 \xa0 \xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n \nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==117) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==106) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==107) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==104) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n  \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then\n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n \n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint_2\')\nhammer=sim.getObjectHandle(\'left_player_2\')\nslider=sim.getObjectHandle("left_slider_2")\njoint_1=sim.getObjectHandle(\'left_joint_3\')\nhammer_1=sim.getObjectHandle(\'left_player_3\')\nslider_1=sim.getObjectHandle("left_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n 第三部分：right1 and right2 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n \nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==2007) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==2008) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==2010) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==2009) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n  \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then\n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n \n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint\')\nhammer=sim.getObjectHandle(\'right_player\')\nslider=sim.getObjectHandle("right_slider")\njoint_1=sim.getObjectHandle(\'right_joint_1\')\nhammer_1=sim.getObjectHandle(\'right_player_1\')\nslider_1=sim.getObjectHandle("right_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n 第四部分：right3 and right4 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n \nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==56) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==53) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==54) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==52) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n  \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then\n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n \n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint_2\')\nhammer=sim.getObjectHandle(\'right_player_2\')\nslider=sim.getObjectHandle("right_slider_2")\njoint_1=sim.getObjectHandle(\'right_joint_3\')\nhammer_1=sim.getObjectHandle(\'right_player_3\')\nslider_1=sim.getObjectHandle("right_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n 手足球模擬-人VS電腦(40623228&40623233) \n 紅色桿子-電腦控制(使用Lua抓取球員及球的位置使球員追蹤及打擊) \n 藍色桿子-鍵盤控制(W鍵:前踢、S鍵:後踢、A鍵:向右移動、D鍵:向左移動) \n \n \n BG2 \n 手足球模擬系統功能展示 (模擬展示與說明影片) \n 單人足球員模擬 (40623249) \n \n 雙人足球員模擬 (40623249) \n \n 人對人 V-rep \xa0(40623220) \n \n (40623249) \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\nlocal joint_r = {\'left_joint1\',\'left_joint3\',\'left_joint5\',\'left_joint7\',}\nlocal joint_b = {\'left_joint\',\'left_joint2\',\'left_joint4\',\'left_joint6\',}\nlocal slider_r ={\'left_slider1\',\'left_slider3\',\'left_slider5\',\'left_slider7\',}\nlocal slider_b ={\'left_slider\',\'left_slider2\',\'left_slider4\',\'left_slider6\',}\nthreadFunction=function()\n\xa0\xa0\xa0\xa0while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- Read the keyboard messages (make sure the focus is on the main window, scene view):\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0message,auxiliaryData=sim.getSimulatorMessage()\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while message~=-1 do\nkey=auxiliaryData[1]\nsim.addStatusbarMessage(\'key:\'..key)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (message==sim.message_keypress) then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (auxiliaryData[1]==2007)or(auxiliaryData[1]==119) then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- up key\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0 (auxiliaryData[1]==119)then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c1=sim.getObjectHandle(joint_r[1])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c2=sim.getObjectHandle(joint_r[2])\xa0 \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c3=sim.getObjectHandle(joint_r[3])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c4=sim.getObjectHandle(joint_r[4])\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c1=sim.getObjectHandle(joint_b[1])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c2=sim.getObjectHandle(joint_b[2])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c3=sim.getObjectHandle(joint_b[3])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c4=sim.getObjectHandle(joint_b[4])\xa0\xa0\xa0 \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0velocity=100\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0torque=200\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0hammer_back = 0\nend\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (auxiliaryData[1]==2008) or (auxiliaryData[1]==115) then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- down key\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0 (auxiliaryData[1]==115)then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c1=sim.getObjectHandle(joint_r[1])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c2=sim.getObjectHandle(joint_r[2])\xa0 \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c3=sim.getObjectHandle(joint_r[3])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c4=sim.getObjectHandle(joint_r[4])\xa0 \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c1=sim.getObjectHandle(joint_b[1])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c2=sim.getObjectHandle(joint_b[2])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c3=sim.getObjectHandle(joint_b[3])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0joint_all_c4=sim.getObjectHandle(joint_b[4])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0hammer_back = 1\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0torque=-200\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0velocity = -100\nend\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (auxiliaryData[1]==2009) or (auxiliaryData[1]==100) then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- right key \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0 (auxiliaryData[1]==100)then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (sliding_r>=0.3)then else sliding_r = sliding_r + 0.05 end\xa0 \nsim.addStatusbarMessage(\'sliding_r:\'..sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (sliding_b>=0.3)then else sliding_b = sliding_b + 0.05 end\nsim.addStatusbarMessage(\'sliding_b:\'..sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (auxiliaryData[1]==2010) or (auxiliaryData[1]==97) then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- left key\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0 (auxiliaryData[1]==97)then\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (sliding_r<=-0.3)then else sliding_r = sliding_r - 0.05 end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\nsim.addStatusbarMessage(\'sliding_r:\'..sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (sliding_b<=-0.3)then else sliding_b = sliding_b - 0.05 end\nsim.addStatusbarMessage(\'sliding_b:\'..sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0message,auxiliaryData=sim.getSimulatorMessage()\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-- We take care of setting the desired hammer position:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if hammer_back == 1\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0then \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c1, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c2, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c3, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c4, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0--sim.setObjectPosition(hammer, -1, position)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c1, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c2, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c3, velocity)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(joint_all_c4, velocity)\n\xa0\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0--sim.setJointForce(joint,torque)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_r_c1, sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_r_c2, sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_r_c3, sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_r_c4, sliding_r)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_b_c1, sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_b_c2, sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_b_c3, sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.setJointTargetPosition(slider_b_c4, sliding_b)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0--Since this script is threaded, don\'t waste time here:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sim.switchThread() -- Resume the script at next simulation loop start\n\xa0\xa0\xa0\xa0end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\n\xa0\njoint_all_c1=sim.getObjectHandle(joint_r[1])\njoint_all_c2=sim.getObjectHandle(joint_r[2])\njoint_all_c3=sim.getObjectHandle(joint_r[3])\njoint_all_c4=sim.getObjectHandle(joint_r[4])\n\xa0\nslider_r_c1=sim.getObjectHandle(slider_r[1])\nslider_r_c2=sim.getObjectHandle(slider_r[2])\xa0 \nslider_r_c3=sim.getObjectHandle(slider_r[3])\nslider_r_c4=sim.getObjectHandle(slider_r[4])\n\xa0\nslider_b_c1=sim.getObjectHandle(slider_b[1])\nslider_b_c2=sim.getObjectHandle(slider_b[2])\xa0 \nslider_b_c3=sim.getObjectHandle(slider_b[3])\nslider_b_c4=sim.getObjectHandle(slider_b[4]) \n\xa0\nhammer=sim.getObjectHandle(\'player\')\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_r = 0\nsliding_b = 0\norientation=sim.getJointPosition(joint_all_c1, -1)\nposition=sim.getObjectPosition(hammer, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n\xa0\xa0\xa0\xa0sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend\n\xa0\xa0\n-- Put some clean-up code here: \n 人對機 (40623249) \n \n 機對機( 40623249) \n \n \n \n \n BG3 \n 手足球模擬系統功能展示 (模擬展示與說明影片) \n <<<<<<< HEAD \n 手足球系統模擬-人 對人(40423160) \n \n 手足球系統模擬-人 對電腦 (40423160) \n \n 手足球系統模擬- 電腦對電腦 (40423160) \n \n 手足球系統模擬-人對人(40623237) \n \n ======= \n 手足球人與人模擬(40623237) \n >>>>>>> scrum-1/master \n \n BG4 \n 手足球模擬系統功能展示 (模擬展示與說明影片) \n 攝影機架設(40423158) \n 主要讓視角更透明 \n \n 第一版手足球模擬-手動對手動(40623225) \n 下載連結: 手動第一版 \n 在11周時將手足球模擬-手動對手動的第一版部分完成 \n \n 第二版手足球模擬-手動對手動(40623225) \n 下載連結: 手動第二版 \n 目前兩邊的守門員都可以手動操作，接下來要將所有足球員放上檯子並且都可手動操作。 \n \n 第三版手足球模擬-手動對手動(40623227): \n 下載連結; 手動第三版 \n 雖已完成全部部分，可是在邊界的設定上還有問題 \n \n 第四版手足球模擬-手動對手動(40623225) \n 下載連結: 手動第四版 \n 邊界上已完全解決問題，目前都能正常運作，只剩送球機構尚未完成。 \n 利用下面的程式限制球員的移動距離。 \n \n \n 最終版手足球模擬-手動對手動(40623225) \n 下載連結: 手動最終版 \n \n \n 第一版手足球模擬-機器對機器(40623227): \n 下載連結; 機器第一版 \n 目前完成守門員對打部分 \n \n 第二版手足球模擬-機器對機器(Final version)(40623227) \n 下載連結: 機器第二版 \n \n 第一版手足球模擬-機器對手動(40623227): \n 下載連結; 機器對手動第一版 \n 目前完成守門員對打部分 \n \n 第二版手足球模擬-機器對手動(40423158): \n 下載連結; 機器對手動第二版 \n 大致上都已完成只缺送球機構，此版本球員還未能準確抓住球路線，但能簡易判定球位址 \n \n 最終版手足球模擬-機器對手動(40423158): \n 參考學弟程式碼再加以小修正 \n 修正 網址 \n 下載連結; 機器對手動(最終版) \n \n \n \n \n BG5 \n 手足球模擬系統功能展示 (模擬展示與說明影片) \n 物件設定步驟 (40623217) \n 人對人程式解說 (40623242)\xa0 \n 人對電腦程式解說 (40623217)\xa0 \n 電腦對電腦程式解說 (40623217)\xa0 \n 人對人(40623242) \n 檔案下載 \n \n 人對電腦 (40623217) \n 檔案下載 \n \n 電腦對電腦(40623217) \n 檔案下載 \n \n 玩家視角 (40623248) \n', 'tags': '', 'url': '系統功能展示.html'}, {'title': '結案報告', 'text': '', 'tags': '', 'url': '結案報告.html'}, {'title': '專案口頭簡報', 'text': 'BG1 \n 各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報) \n Group Reveal \n 40623203 蔡宜芳結案口頭簡報 \n 40623206 邱妍蓁結案口頭簡報 \n 40623212 魏有泉結案口頭簡報 \n 40623221 蔡和勳結案口頭簡報 \n 40623222 蔡博淮結案口頭簡報 \n 40623233 謝宗宏結案口頭簡報 \n 40623240 何冠均結案口頭簡報 \n \n BG2 \n 40623202 吳姍蓉結案口頭簡報 \n 40623209 李芳瑜結案口頭簡報 \n 40623236 黃子峰結案口頭簡報 \n 40623215 吳柏毅結案口頭簡報 \n 40623220 蔡崇廷結案口頭簡報 \n 40623247 廖峻祥結案口頭報告 \n 40623249李秉樺 結案口頭簡報 \n 40623250湯峻傑結案口頭簡報 \n \n BG3 \n 各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報) \n \n 40623237黃博隆專案口頭簡報 \n 40423160 許育誠結案口頭簡報 \n \n 40623231周駿麟專案口頭報告 \n 40623237黃博隆專案口頭簡報 \n 40423160 許育誠結案口頭簡報 \n 40623241 郭祐齊結案口頭簡報 \n 40623237 黃博隆結案口頭簡報 \n \n \n BG4 \n 各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報) \n 40623224 鐘偉哲結案口頭簡報 \n 40623239 許登貴結案口頭簡報 \n 40423158 莊子慶結案口頭簡報 \n 40623227 張耀元結案口頭簡報 \n 40623238 許筌翔結案口頭簡報 \n 40623210 翁嘉宏結案口頭簡報 \n \n BG5 \n 各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報) \n 40623201 王君庭結案口頭簡報 \n 40623217 楊傅博結案口頭簡報 \n 40623223 任明彥結案口頭簡報 \n 40623232 余建杰結案口頭簡報 \n 40623242 高宇辰結案口頭簡報 \n 40623244 林俊鎧結案口頭簡報 \n 40623248 廖柏誠結案口頭簡報', 'tags': '', 'url': '專案口頭簡報.html'}, {'title': '專案報告書', 'text': 'BG1 \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n \n BG2 \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n \n BG3 \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n BG3專案結案報告 \n \n BG4 \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n \n BG5 \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n \n', 'tags': '', 'url': '專案報告書.html'}]};